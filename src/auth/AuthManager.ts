import { OAuth2Client, Credentials } from 'google-auth-library';
import { google } from 'googleapis';
import { calendar_v3 } from 'googleapis';
import { promises as fs } from 'fs';
import { dirname } from 'path';
import { loadOAuthCredentials, getTokenPath } from './config.js';
import { authenticateWithLogging } from './local-auth-helper.js';

export type AuthClient = OAuth2Client;

export interface StoredToken {
  type: string;
  client_id: string;
  client_secret: string;
  refresh_token: string;
}

export interface AuthConfig {
  method: 'oauth2';
  clientId?: string;
  clientSecret?: string;
  redirectUri?: string;
  credentialsDir: string;
  scopes: string[];
}

export enum AuthError {
  INVALID_CREDENTIALS = 'Invalid credentials provided',
  TOKEN_EXPIRED = 'Authentication token has expired',
  REFRESH_FAILED = 'Failed to refresh authentication token',
  NETWORK_ERROR = 'Network error during authentication',
  INVALID_SCOPE = 'Requested scope not authorized',
  RATE_LIMITED = 'Too many authentication attempts',
  UNAUTHENTICATED = 'No valid authentication found',
  CONFIGURATION_ERROR = 'Authentication configuration error',
}

export class AuthenticationError extends Error {
  constructor(
    message: string,
    public code: AuthError,
    public retryable: boolean = false
  ) {
    super(message);
    this.name = 'AuthenticationError';
  }
}

export class CalendarAuthManager {
  private oauth2Client?: OAuth2Client | undefined;
  private currentTokens?: Credentials | undefined;

  private readonly SCOPES = [
    'https://www.googleapis.com/auth/calendar',
    'https://www.googleapis.com/auth/calendar.events',
    'https://www.googleapis.com/auth/calendar.readonly'
  ];

  constructor(_config?: AuthConfig) {
    // Config parameter preserved for API compatibility but not used
    // Credentials are now loaded via config.ts helpers
    // Redirect URI is generated by local-auth-helper.ts
  }
  
  async authenticate(): Promise<AuthClient> {
    console.log('Authenticating with OAuth2');

    try {
      return await this.authenticateOAuth2();
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      console.error('Authentication failed', { error: message });
      throw error;
    }
  }

  async getAuthClient(): Promise<OAuth2Client> {
    return await this.authenticate();
  }

  async getCalendarClient(): Promise<calendar_v3.Calendar> {
    const auth = await this.getAuthClient();
    return google.calendar({ version: 'v3', auth: auth as any });
  }

  private async authenticateOAuth2(): Promise<OAuth2Client> {
    // Try to load existing token from file
    const tokenPath = getTokenPath();
    const token = await this.loadStoredToken(tokenPath);

    if (token) {
      // Test token validity
      try {
        await token.getAccessToken();
        this.oauth2Client = token;
        this.currentTokens = token.credentials;
        console.log('‚úÖ Using existing Calendar API tokens');
        return this.oauth2Client;
      } catch (error) {
        // Token is invalid, need new auth
        console.log('‚ö†Ô∏è  Stored token is invalid, starting new authentication...');
      }
    }

    // Need new authentication
    this.oauth2Client = await this.authenticateNewUser();
    await this.saveToken(this.oauth2Client, tokenPath);
    this.currentTokens = this.oauth2Client.credentials;

    return this.oauth2Client;
  }

  /**
   * Load and validate a stored token
   * Returns null if token is invalid or expired beyond refresh
   */
  private async loadStoredToken(tokenPath: string): Promise<OAuth2Client | null> {
    try {
      const content = await fs.readFile(tokenPath, 'utf-8');
      const credentials = JSON.parse(content) as StoredToken;

      // Create OAuth2 client with stored credentials
      const { client_id, client_secret, redirect_uri } = await loadOAuthCredentials();

      const auth = new google.auth.OAuth2(
        client_id,
        client_secret,
        redirect_uri
      );

      auth.setCredentials({
        refresh_token: credentials.refresh_token,
      });

      // Test if token is valid by attempting to refresh it
      try {
        await auth.getAccessToken();
        return auth as unknown as OAuth2Client;
      } catch (error) {
        return null;
      }
    } catch (error) {
      if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
        return null; // Token file doesn't exist
      }
      throw error;
    }
  }

  /**
   * Perform new OAuth authentication flow
   * Opens browser for user consent
   */
  private async authenticateNewUser(): Promise<OAuth2Client> {
    const credentials = await loadOAuthCredentials();

    try {
      // Use our custom authentication helper with better logging
      const auth = await authenticateWithLogging({
        clientId: credentials.client_id,
        clientSecret: credentials.client_secret,
        scopes: this.SCOPES,
      });

      return auth as unknown as OAuth2Client;
    } catch (error) {
      throw error;
    }
  }

  /**
   * Save authentication token to disk
   */
  private async saveToken(client: OAuth2Client, tokenPath: string): Promise<void> {
    const credentials = await loadOAuthCredentials();
    const tokens = client.credentials;

    if (!tokens.refresh_token) {
      throw new Error('No refresh token received. This should not happen with a new authorization.');
    }

    const tokenData: StoredToken = {
      type: 'authorized_user',
      client_id: credentials.client_id,
      client_secret: credentials.client_secret,
      refresh_token: tokens.refresh_token,
    };

    // Ensure directory exists
    await fs.mkdir(dirname(tokenPath), { recursive: true });

    // Save token
    await fs.writeFile(tokenPath, JSON.stringify(tokenData, null, 2));
    console.log('‚úÖ Calendar API tokens saved successfully');
  }

  async refreshTokens(): Promise<void> {
    if (!this.oauth2Client || !this.currentTokens?.refresh_token) {
      throw new AuthenticationError(
        'No refresh token available',
        AuthError.REFRESH_FAILED
      );
    }

    try {
      const { credentials } = await this.oauth2Client.refreshAccessToken();
      this.oauth2Client.setCredentials(credentials);
      this.currentTokens = credentials;

      // Note: Refresh tokens persist, so we don't need to save again
      // The stored token.json already contains the refresh_token

      console.log('üîÑ Calendar API tokens refreshed successfully');
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      throw new AuthenticationError(
        `Token refresh failed: ${message}`,
        AuthError.REFRESH_FAILED
      );
    }
  }
  
  async clearTokens(): Promise<void> {
    const tokenPath = getTokenPath();

    // Delete stored token
    try {
      await fs.unlink(tokenPath);
    } catch (error) {
      if ((error as NodeJS.ErrnoException).code !== 'ENOENT') {
        throw error;
      }
    }

    this.currentTokens = undefined;
    this.oauth2Client = undefined;

    console.log('üóëÔ∏è Calendar API tokens cleared');
  }
  
  getClient(): AuthClient | null {
    return this.oauth2Client || null;
  }

  isAuthenticated(): boolean {
    return !!(this.oauth2Client?.credentials?.access_token);
  }

  getCurrentTokens(): Credentials | null {
    return this.currentTokens || null;
  }
}

/**
 * Factory function to create CalendarAuthManager instances
 * Used by tools to create fresh auth instances
 */
export function createCalendarAuth(): CalendarAuthManager {
  return new CalendarAuthManager();
}